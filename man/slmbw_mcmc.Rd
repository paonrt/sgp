% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slmbw_mcmc.R
\name{slmbw_mcmc}
\alias{slmbw_mcmc}
\title{Spatial Linear Regression Modeling Binomial and Weibull Distributions}
\usage{
slmbw_mcmc = function(nsim, W, S, Sstar, startingPoint = NULL,
                      details = FALSE, forecasting = TRUE,
                      burn = 0, thin = 1, verbose = +Inf)
}
\arguments{
\item{nsim}{The number of simulations.}

\item{W}{List of sublists containing Weibull realizations.}

\item{S}{Matrix of covariates for observed point.}

\item{Sstar}{Matrix of covariates for interpolating points.}

\item{startingPoint}{List for starting point.}

\item{details}{If it is true then also values of Gamma, Delta, and Pi are
collected (large memory consumption).}

\item{forecasting}{If it true then hyper-parameters values at interpolating
points are collected.}

\item{burn}{The number of draws to be discarded as burn-in.}

\item{thin}{The thinning parameter.}

\item{verbose}{The period for printing status of the chain.}
}
\value{
A named list containing a posterior sample.
}
\description{
Markov chain Monte Carlo (MCMC) algorithm for linear spatial model.
}
\details{
The parametrization for Weibull is such that \eqn{\mathrm{E}(W) = \log
 (\delta) \: \Gamma \big( 1 + 1 / \log(\gamma) \big)}.

Binomial parameters are \eqn{n = 365} and \eqn{p = (1 + \exp \big( -\pi)
 \big)^{-1}}.

\code{W}: list containing sublists for each observed point. Each sublist
contains a vector of Weibull realizations. There is a vector for each year,
thus, the length of each vector determines the binomial draws.

\code{S}: matrix containing covariates of observed points. One column for
each covariates and one row for each observed point. Note that, \eqn{i}-th
row of \code{S} contains covariates for observed point with draws collected
at the \eqn{i}-th sublist of \code{W}.

\code{Sstar}: matrix containing covariates of interpolating points.
One column for each covariates and one row for each observed point.

\code{startingPoint}: the starting point is generated in the following way:
\itemize{
\item if \code{startingPoint == NULL} then:
\enumerate{
\item set \code{Pi} equal to the MLE,
\item set \code{beta_pi = solve(t(S) \%*\% S) \%*\% t(S) \%*\%
     rowMeans(Pi)},
\item set \code{sigmaSq_pi = mean((Pi - S \%*\% beta_pi) ^ 2)},
\item do the same for \code{Gamma} and \code{Delta} and their
hyper-parameters.
}
\item \code{else} it must be a named list with names equal to the variables
to be initialized
}

Only one value every \code{thin} values is kept in the chain, so the true
number of complete scans will be \code{nsim * thin + burn}. By default
\code{thin = 1}, that is no thinning.

The current time and the current number of iteration are printed one every
\code{verbose} iterations. Furthermore:
\itemize{
\item if \code{verbose == +-Inf} then there is no printing,
\item if \code{verbose != +-Inf} then at least start and end of simulation
are reported.
}
}
\references{
...
}
